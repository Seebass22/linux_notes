* variables
  - variables are immutable by default
    - use =mut= to make them mutable
  - you can reuse variable names to "shadow" other variables

* types
** compound types
*** tuple
    - can contain multiple types
    - fixed length
      #+begin_src rust
	fn main() {
	    // optional type annotation
	    let tup2: (i32, f64, u8) = (500, 6.4, 1);

	    let tup = (500, 6.4, 1);
	    // use pattern matching to destructure tuple
	    let (x, y, z) = tup;
	    println!("The value of y is: {}", y);

	    // access elements directly using .
	    let five_hundred = x.0;
	    let six_point_four = x.1;
	    let one = x.2;
	}
      #+end_src

*** arrays
    - elements have same type
    - fixed length
    - can be sliced just like strings
      #+begin_src rust
	let months = ["January", "February", "March", "April", "May", "June", "July",
		      "August", "September", "October", "November", "December"];
	let a: [i32; 5] = [1, 2, 3, 4, 5];
	// array countaining the same element multiple times
	// [value; length]
	let a = [3; 5]; // -> [3, 3, 3, 3, 3]
      #+end_src

* collections
  data structures in the standard library
  - stored on heap
** vectors
   #+begin_src rust
     let v: Vec<i32> = Vec::new();

     v.push(5);
     v.push(6);
     v.push(7);
     v.push(8);
   #+end_src

*** =vec!= macro
    create a vector with initial values
    #+begin_src rust
      let v = vec![1, 2, 3];
    #+end_src

*** reading elements
    #+begin_src rust
      let v = vec![1, 2, 3, 4, 5];
      let third: &i32 = &v[2];

      println!("The third element is {}", third);

      match v.get(2) {
	  Some(third) => println!("The third element is {}", third),
	  None => println!("There is no third element."),
      }
    #+end_src

*** iterating over vector
    #+begin_src rust
      // iterate over vector
      let v = vec![100, 32, 57];
      for i in &v {
	  println!("{}", i);
      }

      // iterate over mutable reference to vector
      let mut v = vec![100, 32, 57];
      for i in &mut v {
	  ,*i += 50;
      }
    #+end_src

** hash maps
   - key/value pairs
   #+begin_src rust
     use std::collections::HashMap;

     let mut scores = HashMap::new();
     scores.insert(String::from("Blue"), 10);
     scores.insert(String::from("Yellow"), 50);

     // access values
     let team_name = String::from("Blue");
     let score = scores.get(&team_name);
     // returns Some(&10)
     // would return None if no value for the key exists
   #+end_src

*** create hash map from vectors
    #+begin_src rust
      use std::collections::HashMap;

      let teams = vec![String::from("Blue"), String::from("Yellow")];
      let initial_scores = vec![10, 50];

      let scores: HashMap<_, _> = teams.iter()
      // create vector of tuples (Blue, 10), (Yellow, 50)
	  .zip(initial_scores.iter())
      // turn into hash map
	  .collect();
    #+end_src

*** iterate over key/value pairs
    #+begin_src rust
      for (key, value) in &scores {
	  println!("{}: {}", key, value);
      }
    #+end_src

*** iterate over keys
    =.keys()=

*** iterate over values
    =.values()=

*** overwrite value
    #+begin_src rust
      scores.insert(String::from("Blue"), 10);
      scores.insert(String::from("Blue"), 25);
    #+end_src

*** only insert if key has no value
    #+begin_src rust
      scores.entry(String::from("Yellow")).or_insert(50);
      scores.entry(String::from("Blue")).or_insert(50);
    #+end_src

*** update value based on its old value
    - =or_insert= returns a mutable reference to the value
    #+begin_src rust
      use std::collections::HashMap;

      let text = "hello world wonderful world";
      let mut map = HashMap::new();

      for word in text.split_whitespace() {
	  let count = map.entry(word).or_insert(0);
	  ,*count += 1;
      }
      println!("{:?}", map);
      // {"world": 2, "hello": 1, "wonderful": 1}
    #+end_src

* structs
  - cannot be partially mutable, only completely mutable or immutable
  #+begin_src rust
    // define a struct
    struct User {
	username: String,
	email: String,
	sign_in_count: u64,
	active: bool,
    }

    // create an instance
    let mut user1 = User {
	email: String::from("someone@example.com"),
	username: String::from("someusername123"),
	active: true,
	sign_in_count: 1,
    };

    // set a field
    user1.email = String::from("anotheremail@example.com");
  #+end_src
** field init shorthand
   - possible if variable and field have the same name
     #+begin_src rust
       fn build_user(email: String, username: String) -> User {
	   User {
	       email,
	       username,
	       active: true,
	       sign_in_count: 1,
	   }
       }
     #+end_src

** struct update syntax
   create a new instance, using values from an existing instance
   #+begin_src rust
     let user2 = User {
	 email: String::from("another@example.com"),
	 username: String::from("anotherusername567"),
	 // set remaining fields (active and sign_in_count) to values from user1
	 ..user1
     };
   #+end_src

** tuple structs
   - similar to tuples, but named
   - fields are unnamed
     #+begin_src rust
       struct Color(i32, i32, i32);
       struct Point(i32, i32, i32);

       let black = Color(0, 0, 0);
       let origin = Point(0, 0, 0);
     #+end_src

** print debug info
   #+begin_src rust
     #[derive(Debug)]
     struct Rectangle {width: u32, height: u32}

     fn main() {
	 let rect1 = Rectangle { width: 30, height: 50 };

	 // compact form
	 println!("rect1 is {:?}", rect1);
	 // less compact form
	 println!("rect1 is {:#?}", rect1);
     }
   #+end_src

** methods
   - first parameter is always self
   #+begin_src rust
     struct Rectangle {
	 width: u32,
	 height: u32,
     }

     // implementation block
     impl Rectangle {
	 fn area(&self) -> u32 {
	     self.width * self.height
	 }
     }

     fn main() {
	 let rect1 = Rectangle { width: 30, height: 50 };
	 println!(
	     "The area of the rectangle is {} square pixels.",
	     // call method
	     rect1.area()
	 );
     }
   #+end_src

** associated functions
   - like static methods in other languages
   - not associated with an instance
   - often used as constructors
   - use =::= to call
     #+begin_src rust
       impl Rectangle {
	   fn square(size: u32) -> Rectangle {
	       Rectangle { width: size, height: size }
	   }
       }

       fn main(){
	   let sq = Rectangle::square(3)
       }
     #+end_src

* enums
  - can have methods
  - can contain data (of different types)
    #+begin_src rust
      enum IpAddr {
	  V4(u8, u8, u8, u8),
	  V6(String),
      }
      let home = IpAddr::V4(127, 0, 0, 1);
      let loopback = IpAddr::V6(String::from("::1"));
    #+end_src

** option enum
   #+begin_src rust
     enum Option<T> {
	 Some(T),
	 None,
     }
   #+end_src
   - automatically included in prelude
   - can use =Some= and =None= without =Option::= prefix
   #+begin_src rust
     let some_number = Some(5);
     let some_string = Some("a string");
     let absent_number: Option<i32> = None;
   #+end_src
   - use =match= to get value
   #+begin_src rust
     fn plus_one(x: Option<i32>) -> Option<i32> {
	 // return None if None
	 // else add 1 to value
	 match x {
	     None => None,
	     Some(i) => Some(i + 1),
	 }
     }
     let five = Some(5);
     let six = plus_one(five);
     let none = plus_one(None);
   #+end_src
   - use =unwrap= to return value (only if you're sure a value is present)
     - will panic if None
  
* functions
  - names in =snake_case=
  - can be defined anywhere (even after their use)
  - type annotations required in parameter list
  - passing a variable to a function will move or copy it
    #+begin_src rust
      fn main() {
	  function(5, 8);
      }

      fn function(x: i32, y: u32) {
	  println!("The value of x is: {}", x);
	  println!("The value of y is: {}", y);
      }
    #+end_src

** returning values
   - return value is the value of the final expresssion in the function body
   - (expressions do not use semicolons)
   #+begin_src rust
     fn five() -> i32 {
	 5
     }
     fn main() {
	 let x = five();
	 println!("The value of x is: {}", x);
     }
   #+end_src

* if
  - no parentheses required
  - is an expression
    - can be used in a let statement
      #+begin_src rust
	let condition = true;
	let number = if condition {
	    5
	} else {
	    6
	};
      #+end_src

* loops
** loop
   - infinite loop
     #+begin_src rust
       loop {
	   println!("again!");
       }
     #+end_src
   - break out with =break=
   - can return a value
     #+begin_src rust
       let mut counter = 0;

       let result = loop {
	   counter += 1;
	   if counter == 10 {
	       break counter * 2;
	   }
       };
     #+end_src

** while
   #+begin_src rust
     let mut number = 3;

     while number != 0 {
	 println!("{}!", number);
	 number = number - 1;
     }
   #+end_src

** for
   #+begin_src rust
     let a = [10, 20, 30, 40, 50];

     for element in a.iter() {
	 println!("the value is: {}", element);
     }
   #+end_src

* use
  #+begin_src rust
    std::io::Stdin
  #+end_src
  is equivalent to
  #+begin_src rust
    use std::io;

    io::Stdin
  #+end_src
  - works with user defined modules too
    #+begin_src rust
      mod front_of_house {
	  pub mod hosting {
	      pub fn add_to_waitlist() {}
	  }
      }

      use crate::front_of_house::hosting;
      // or use relative path
      // use front_of_house::hosting;

      pub fn eat_at_restaurant() {
	  hosting::add_to_waitlist();
	  hosting::add_to_waitlist();
      }
    #+end_src

** nested paths
   #+begin_src rust
     use std::{io, cmp::Ordering};
   #+end_src

** glob operator
   - brings all public items into scope
     #+begin_src rust
       use std::collections::*;
     #+end_src

** =as= keyword
   - allows you to use a different name
     #+begin_src rust
       use std::fmt::Result;
       use std::io::Result as IoResult;

       fn function1() -> Result {
	   // --snip--
       }
       fn function2() -> IoResult<()> {
	   // --snip--
       }
     #+end_src

** re-exporting with =pub use=
   - bring an item into scope and make it available for others
   #+begin_src rust
     // allow external code to call hosting::add_to_waitlist without full path
     pub use crate::front_of_house::hosting;
   #+end_src
  
* match
  - like a switch statement
  - can extract values from enums 
  - must cover every possible case
  - =_= matches any value
  #+begin_src rust
    match guess.cmp(&secret_number) {
	Ordering::Less => println!("Too small!"),
	Ordering::Greater => println!("Too big!"),
	Ordering::Equal => {
	    println!("You win!");
	    break;
	}
    }

    let some_u8_value = 0u8;
    match some_u8_value {
	1 => println!("one"),
	3 => println!("three"),
	5 => println!("five"),
	7 => println!("seven"),
	_ => (),
    }
  #+end_src

* if let
  - takes a pattern and expression separated by equals
    #+begin_src rust
      let some_u8_value = Some(0u8);

      if let Some(3) = some_u8_value {
	  println!("three");
      }

      // same as
      match some_u8_value {
	  Some(3) => println!("three"),
	  _ => (),
      }
    #+end_src
  
* mutability
  variables are immutable by default
  #+begin_src rust
    let x = 5;
    println!("the value of x is: {}", x);
    // compiler error
    x = 6;
    println!("the value of x is: {}", x);
  #+end_src
  use keyword =mut= for mutable variables
  #+begin_src rust
    let mut x = 5;
    println!("the value of x is: {}", x);
    x = 6;
    println!("the value of x is: {}", x);
  #+end_src
  
* shadowing
  lets you reuse names of variables
  #+begin_src rust
    let x = 5;
    let x = x + 1;
    let x = x * 2;
    println!("The value of x is: {}", x);
  #+end_src
  lets you change type
  #+begin_src rust
    let spaces = "   "
	let spaces = spaces.len();
  #+end_src
  
* constants
  - immutable
  - must be type-annotated
  - can be declared in any scope
  - must be set to a constant expression (cannot be computed at runtime)
    #+begin_src rust
      const MAX_POINTS: u32 = 100_000;
    #+end_src

* strings
** string literals
   - immutable
   - stack allocated
   - =&str= type
     #+begin_src rust
       let s = "hello";
     #+end_src

** =String= type
   - mutable
   - heap allocated
     #+begin_src rust
       let s = String::from("hello");
       // append a literal to string
       s.push_str(", world!");
       // duplicate string
       let s2 = s.clone();
       // append single character
       let mut s3 = String::from("lo");
       s3.push('l');
       // concatenate 2 strings
       let s1 = String::from("Hello, ");
       let s2 = String::from("world!");
       let s3 = s1 + &s2; // s1 has been moved here and can no longer be used
       // alternatively use format! macro
     #+end_src
   - reassigning a =String= invalidates the old reference
     #+begin_src rust
       let s1 = String::from("hello");
       let s2 = s1;
       // compiler error
       println!("{}, world!", s1);
     #+end_src

*** to_string
    - works on any type that implements the =Display= trait
    #+begin_src rust
      let data = "initial contents";
      let s = data.to_string();
      // also works on a literal directly
      let s = "initial contents".to_string();
    #+end_src

*** =format!= macro
    - works like println! but returns a string instead of printing it
    #+begin_src rust
      let s1 = String::from("tic");
      let s2 = String::from("tac");
      let s3 = String::from("toe");

      let s = format!("{}-{}-{}", s1, s2, s3);
    #+end_src

*** iterating over strings
**** over unicode scalar values
     #+begin_src rust
       // return chars
       for c in "नमस्त".chars() {
	   println!("{}", c);
       }

       // return raw bytes
       for b in "नमस्त".bytes() {
	   println!("{}", b);
       }
     #+end_src

*** check if string contains substring
    #+begin_src rust
      if s.contains("ab") {
	  //..
      }
    #+end_src

** string slices
   - reference to part of a string
   - range indices must occur at valid UTF-8 character boundaries
   - are of type =&str=
     #+begin_src rust
       let s = String::from("hello world");
       // [start..end]
       // does not in include "end" element
       let hello = &s[0..5];
       let world = &s[6..11];

       // you can omit the start or end if the slice includes it
       let hello = &s[..5];
       let world = &s[6..];
       // omit both values to create slice of entire string
       let slice = &s[..];
     #+end_src
   - use =&str= as function parameter instead of =&String= to make a function more general
     - allows passing both string slices (incl. string literals) and Strings
   #+begin_src rust
     fn first_word(s: &str) -> &str {
     }

     fn main() {
	 let my_string = String::from("hello world");

	 // pass slice of entire string
	 let word = first_word(&my_string[..]);

	 let my_string_literal = "hello world";
	 // pass a string literal
	 let word = first_word(&my_string_literal[..]);
	 // no need to use slice syntax since string literals are already slices
	 let word = first_word(my_string_literal);
     }
   #+end_src
   - there are array slices too, which work in the same way

* ownership
  - every value in rust has an owner
  - there can only be one owner at a time
  - when the owner goes out of scope, the value is dropped (deallocated)
  - functions take ownership of parameters
    #+begin_src rust
      {
	  let s1 = String::from("hello"); // s1 is valid
      } // s1 is no longer valid

      let s2 = String::from("hello"); // s2 comes into scope
      takes_ownership(s2); // s2's value moves into the function...
      // ... and so is no longer valid here

      let x = 5; // x comes into scope
      makes_copy(x); // x is copied (i32 is a copy type)
      // x is still valid
    #+end_src
** references
   - refer to something but do not own it
   - allow calling functions without transfering ownership
     #+begin_src rust
       fn main() {
	   let s1 = String::from("hello");
	   let len = calculate_length(&s1);
	   println!("The length of '{}' is {}.", s1, len);
       }

       fn calculate_length(s: &String) -> usize {
	   s.len()
       }
     #+end_src
   - do not allow modifying "borrowed" variable unless mutable
   - only one mutable reference to a piece of data can exist in a scope
     #+begin_src rust
       let mut s = String::from("hello");
       let r1 = &mut s;
       // compiler error
       let r2 = &mut s;
     #+end_src
   - cannot combine mutable and immutable references
     #+begin_src rust
       let mut s = String::from("hello");
       let r1 = &s; // no problem
       let r2 = &s; // no problem
       // compiler error
       let r3 = &mut s;
     #+end_src
   - cannot be dangling (must be valid)

* error handling
** =Result= enum
   #+begin_src rust
     enum Result<T, E> {
	 Ok(T),
	 Err(E),
     }
   #+end_src
   - automatically included in prelude, like =Option=

** expect
   print error message and quit on error
   - works like =unwrap=
   #+begin_src rust
     let mut guess = String::new();
     io::stdin().read_line(&mut guess)
	 .expect("Failed to read line");
   #+end_src

** handle error with match
   #+begin_src rust
     let guess: u32 = match guess.trim().parse() {
	 Ok(num) => num,
	 // skip to next loop iteration on error
	 Err(_) => continue,
     };
   #+end_src

*** match multiple error types
    #+begin_src rust
      use std::fs::File;
      use std::io::ErrorKind;

      fn main() {
	  let f = File::open("hello.txt");

	  let f = match f {
	      Ok(file) => file,
	      Err(error) => match error.kind() {
		  ErrorKind::NotFound => match File::create("hello.txt") {
		      Ok(fc) => fc,
		      Err(e) => panic!("Problem creating the file: {:?}", e),
		  },
		  other_error => panic!("Problem opening the file: {:?}", other_error),
	      },
	  };
      }
    #+end_src

** =unwrap_or_else=
   - unwraps if Ok
   - calls function/closure if Err

** propogating errors
   - return a =Result=
   #+begin_src rust
     use std::io;
     use std::io::Read;
     use std::fs::File;

     fn read_username_from_file() -> Result<String, io::Error> {
	 let f = File::open("hello.txt");
	 let mut f = match f {
	     Ok(file) => file,
	     Err(e) => return Err(e),
	 };

	 let mut s = String::new();
	 match f.read_to_string(&mut s) {
	     Ok(_) => Ok(s),
	     Err(e) => Err(e),
	 }
     }
   #+end_src

*** shorthand: =?= operator
    - returns value inside Ok to expression if Ok
    - returns Err from the whole function if Err
      - uses =From= trait to convert between error types
      - can only be used in functions that return =Result= enum
    #+begin_src rust
      use std::io;
      use std::io::Read;
      use std::fs::File;

      fn read_username_from_file() -> Result<String, io::Error> {
	  let mut f = File::open("hello.txt")?;
	  let mut s = String::new();
	  f.read_to_string(&mut s)?;
	  Ok(s)
      }
    #+end_src
    or chain calls
    #+begin_src rust
      use std::io;
      use std::io::Read;
      use std::fs::File;

      fn read_username_from_file() -> Result<String, io::Error> {
	  let mut s = String::new();
	  File::open("hello.txt")?.read_to_string(&mut s)?;
	  Ok(s)
      }
    #+end_src

** any kind of error
   =Box<dyn Error>>=

* generics
** functions
   #+begin_src rust
     fn do_something<T>(list: &[T]) -> T {
     }
   #+end_src

** structs and methods
   #+begin_src rust
     struct Point<T> {
	 x: T,
	 y: T,
     }

     // method for all types
     impl<T> Point<T> {
	 fn x(&self) -> &T {
	     &self.x
	 }
     }

     // method just for f32
     impl Point<f32> {
	 fn distance_from_origin(&self) -> f32 {
	     (self.x.powi(2) + self.y.powi(2)).sqrt()
	 }
     }
   #+end_src

* traits
  - similar to interfaces in other languages
  - can only be implemented if the trait or type is local to the crate
    (can't implement external traits on external types)
    #+begin_src rust
      // trait definition
      pub trait Summary {
	  fn summarize(&self) -> String;
      }

      pub struct NewsArticle {
	  pub headline: String,
	  pub location: String,
	  pub author: String,
	  pub content: String,
      }

      // implement Summary trait for NewsArticle
      impl Summary for NewsArticle {
	  fn summarize(&self) -> String {
	      format!("{}, by {} ({})", self.headline, self.author, self.location)
	  }
      }

      pub struct Tweet {
	  pub username: String,
	  pub content: String,
	  pub reply: bool,
	  pub retweet: bool,
      }

      // implement Summary trait for Tweet
      impl Summary for Tweet {
	  fn summarize(&self) -> String {
	      format!("{}: {}", self.username, self.content)
	  }
      }
    #+end_src

** default implementations
   - can mix default and required implementations in one trait
   - cannot call default implementation from overriding one
   #+begin_src rust
     // definition
     pub trait Summary {
	 fn summarize(&self) -> String {
	     String::from("(Read more...)")
	 }
     }

     // use default implementation of Summary for NewsArticle
     impl Summary for NewsArticle {}
   #+end_src

** traits as parameters
   #+begin_src rust
     // takes any type that implements Summary trait as parameter
     pub fn notify(item: impl Summary) {
	 println!("Breaking news! {}", item.summarize());
     }
   #+end_src

*** trait bound syntax
    #+begin_src rust
      pub fn notify<T: Summary>(item: T) {
	  println!("Breaking news! {}", item.summarize());
      }
    #+end_src

*** multiple trait bounds
    #+begin_src rust
      pub fn notify(item: impl Summary + Display) {}
      // or
      pub fn notify<T: Summary + Display>(item: T) {}
    #+end_src

*** =where= clauses
    #+begin_src rust
      fn some_function<T, U>(t: T, u: U) -> i32
      where T: Display + Clone,
	    U: Clone + Debug
      {}
      // same as
      fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {}
    #+end_src

*** conditionally implement method if traits are implemented
    #+begin_src rust
      impl<T: Display + PartialOrd> Pair<T> {
    #+end_src

*** implement trait if other traits are implemented
    #+begin_src rust
      impl<T: Display> ToString for T {
    #+end_src

** traits as return types
   - only works if function/method returns only one type
   #+begin_src rust
     fn returns_summarizable() -> impl Summary {
   #+end_src

* lifetime annotations
  - don't change how long references live
  - describe the relationships of the lifetimes of multiple references to each other
  - tell the borrow checker how to behave (to allow code to compile)
  #+begin_src rust
    &i32 // a reference
	&'a i32 // a reference with an explicit lifetime
	&'a mut i32 // a mutable reference with an explicit lifetime
  #+end_src
** in function signatures
   - functions that return references usually require lifetime annotations
   #+begin_src rust
     fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
	 //...
     }
   #+end_src

*** lifetime elision
    exceptions that don't require lifetime annotations
    - each reference parameter gets its own lifetime parameter
    - if there is 1 input lifetime parameter, all output lifetime parameters get that lifetime
    - if one input lifetime parameter is =&self= or =&mut self=, the output lifetime is the lifetime of self

** in struct definitions
   - structs that contain references require lifetime annotations
   #+begin_src rust
     struct ImportantExcerpt<'a> {
	 part: &'a str,
     }
   #+end_src

** in methods
   #+begin_src rust
     impl<'a> ImportantExcerpt<'a> {
	 fn level(&self) -> i32 {
	     3
	 }

	 // no lifetimes required due to lifetime elision rules
	 fn announce_and_return_part(&self, announcement: &str) -> &str {
	     println!("Attention please: {}", announcement);
	     self.part
	 }
     }
   #+end_src

** static lifetimes
   - live the entire duration of the program
   - string literals always have static lifetimes

* tests
  - tests fail if panic occurs
  #+begin_src rust
    #[derive(Debug)]
    pub struct Rectangle {
	length: u32,
	width: u32,
    }
    impl Rectangle {
	pub fn can_hold(&self, other: &Rectangle) -> bool {
	    self.length > other.length && self.width > other.width
	}
    }

    #[cfg(test)]
    mod tests {
	// bring contents of outer module into scope
	use super::*;

	#[test]
	fn larger_can_hold_smaller() {
	    let larger = Rectangle { length: 8, width: 7 };
	    let smaller = Rectangle { length: 5, width: 1 };

	    assert!(larger.can_hold(&smaller));
	}

	#[test]
	fn smaller_cannot_hold_larger() {
	    let larger = Rectangle { length: 8, width: 7 };
	    let smaller = Rectangle { length: 5, width: 1 };

	    assert!(!smaller.can_hold(&larger));
	}
    }
  #+end_src

** =assert!= macro
   - does nothing if value evaluates to true
   - panics if value evaluates to false

*** print error message on failure
    #+begin_src rust
      let result = greeting("Carol");
      assert!(
	  result.contains("Carol"),
	  "Greeting did not contain name, value was `{}`", result
      );
    #+end_src

** =assert_eq!= and =assert_ne!= macros
   - check if two values are equal or not equal
     #+begin_src rust
       assert_eq!(4, add_two(2));
     #+end_src

** asserting that a panic happened
   #+begin_src rust
     #[test]
     #[should_panic]
     fn greater_than_100() {
	 Guess::new(200);
     }
   #+end_src

*** check if error message contains substring
    - specify a substring of the error message (leave out dynamic content)
    #+begin_src rust
      #[test]
      #[should_panic(expected = "Guess value must be less than or equal to 100")]
      fn greater_than_100() {
	  Guess::new(200);
      }
    #+end_src

** using =Result<T, E>= in tests
   - return =Ok(())= on success
   - return =Err= with an error message string on fail
   - allows using the =?= operator to fail if any operation in test fails
   - can't use =#[should_panic]= in tests that return =Result<T, E>=

** ignoring tests by default
   #+begin_src rust
     #[test]
     #[ignore]
     fn expensive_test() {
	 // code that takes an hour to run
     }
   #+end_src

** integration tests
   - in =tests= directory
   - put common code in a subdirectory in =tests=, such as =tests/common/rust.rs=
     #+begin_src rust
       use adder;

       #[test]
       fn it_adds_two() {
	   assert_eq!(4, adder::add_two(2));
       }
     #+end_src

*** binary crates
    - can't create integration tests in =tests= and bring functions from =src/main.rs= into scope with use

* modules
  - put something in a module if you want it to be private
  #+begin_src rust
    mod front_of_house {
	pub mod hosting {
	    pub fn add_to_waitlist() {}
	}
    }
  #+end_src
  - can be called with absolute (with =crate::=) or relative path
    #+begin_src rust
      pub fn eat_at_restaurant() {
	  // Absolute path
	  crate::front_of_house::hosting::add_to_waitlist();
	  // Relative path
	  front_of_house::hosting::add_to_waitlist();
      }
    #+end_src
  - reference parent module with =super::=
    #+begin_src rust
      fn serve_order() {}

      mod back_of_house {
	  fn fix_incorrect_order() {
	      cook_order();
	      super::serve_order();
	  }

	  fn cook_order() {}
      }
    #+end_src

** public structs
   - use keyword =pub= to designate structs and enums as public
   - the fields will remain private, can be made public on case-by-case basis
     #+begin_src rust
       mod back_of_house {
	   pub struct Breakfast {
	       pub toast: String,
	       seasonal_fruit: String,
	   }

	   impl Breakfast {
	       pub fn summer(toast: &str) -> Breakfast {
		   Breakfast {
		       toast: String::from(toast),
		       seasonal_fruit: String::from("peaches"),
		   }
	       }
	   }
       }
       pub fn eat_at_restaurant() {
	   // Order a breakfast in the summer with Rye toast
	   let mut meal = back_of_house::Breakfast::summer("Rye");
	   // Change our mind about what bread we'd like
	   meal.toast = String::from("Wheat");
	   println!("I'd like {} toast please", meal.toast);

	   // compiler error - cannot modify private field seasonal_fruit
	   meal.seasonal_fruit = String::from("blueberries");
       }
     #+end_src

** public enums
   - enums are public by default

* closures
  - don't require type annotations
  - brackets are optional if body only contains one expression
  - always implement one of =Fn=, =FnMut= or =FnOnce= traits
    #+begin_src rust
      fn add_one_v1 (x: u32) -> u32 { x + 1 }
      // all equivalent
      let add_one_v2 = |x: u32| -> u32 { x + 1 };
      let add_one_v3 = |x| { x + 1 };
      let add_one_v4 = |x| x + 1;
    #+end_src
  - can use variables from their environment (unlike functions)
    #+begin_src rust
      fn main() {
	  let x = 4;
	  let equal_to_x = |z| z == x;
	  let y = 4;
	  assert!(equal_to_x(y));
      }
    #+end_src

** closure traits
   - are inferred based on how values from environment are used
*** =FnOnce=
    - take ownership of variables from environment
    - use keyword =move= to force this
*** =FnMut=
    - can change environment
*** =Fn=
    - only borrow values immutably

* iterators
  iterator adaptors are lazy and don't do anything until they're consumed
** iterate
*** return immutable references
    =iter=
*** return mutable references
    =iter_mut=
*** return owned values (and take ownership of item being iterated over)
    =into_iter=

** =collect=
   consumes the iterator and collects the results into a collection data type

** =map=
   perform an action on each element
   #+begin_src rust
     let v1: Vec<i32> = vec![1, 2, 3];
     let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();
     // => vec![2, 3, 4]
   #+end_src

** =filter=
   - takes a closure that returns a boolean
   - returns the items for which that closure returns true (filters out the rest)
   - use =filter_map= to combine with =map=
     #+begin_src rust
       fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
	   shoes.into_iter()
	       .filter(|s| s.size == shoe_size)
	       .collect()
       }
     #+end_src

** =fold=
   fold every element into an accumulator by apply an operation, return final result
   #+begin_src rust
     let a = [1, 2, 3, 4];

     // product of the elements
     let sum = a.iter().fold(1, |acc, x| acc * x);
     assert_eq!(sum, 6);
   #+end_src

** =flatten=
   creates an iterator that flattens a nested structure
   - use =flat_map= to combine with =map=
   #+begin_src rust
     let data = vec![vec![1, 2, 3, 4], vec![5, 6]];
     let flattened = data.into_iter().flatten().collect::<Vec<u8>>();
     assert_eq!(flattened, &[1, 2, 3, 4, 5, 6]);
   #+end_src

** =zip=
   zip up 2 iterators into an iterator of tuples
   #+begin_src rust
     let s1 = &[1, 2, 3];
     let s2 = &[4, 5, 6];

     let mut iter = s1.iter().zip(s2);

     assert_eq!(iter.next(), Some((&1, &4)));
     assert_eq!(iter.next(), Some((&2, &5)));
     assert_eq!(iter.next(), Some((&3, &6)));
     assert_eq!(iter.next(), None);
   #+end_src

** create an iterator on custom types
   - implement =Iterator= trait: write =next= method

* smart pointers
** =Box<T>=
   - box stored on stack, data stored on heap
    #+begin_src rust
      fn main() {
	  // store an i32 on the heap
	  let b = Box::new(5);
	  println!("b = {}", b);
      }
    #+end_src

** =Rc<T>=
   - reference counting
   - enables multiple owners of the same data
   - allows immutable borrows checked at runtime
   - only used for single-threaded scenarios
   - calling =Rc::clone= increases the reference count

*** =downgrade=
    returns a weak reference of type =Weak<T>=
    - increases only =weak_count= rather than reference count

*** =upgrade=
    upgrades a weak reference to a =Rc<T>=
    - returns an =Option<RC<T>>=
    - None if value has been dropped

** RefCell<T>
   - only used for single-threaded scenarios
   - allows mutable (and immutable) borrows checked at runtime
   - can mutate data even when the =RefCell<T>= is immutable

*** =borrow=
    - returns an immutable =Ref<T>= smart pointer

*** =borrow_mut=
    - returns a =RefMut<T>= smart pointer that allows mutating the inner value

** implementing dereferencing
   - return a plain reference to data
   #+begin_src rust
     use std::ops::Deref;

     impl<T> Deref for MyBox<T> {
	 type Target = T;

	 fn deref(&self) -> &T {
	     &self.0
	 }
     }
   #+end_src

** deref coercion
   rust automatically calls =deref= to convert a parameter to the one required (as long as this can be achieved through dereferencing)
   - resolved at compile time -> no runtime performance penalty
   #+begin_src rust
     fn hello(name: &str) {
	 println!("Hello, {}!", name);
     }

     fn main() {
	 let m = MyBox::new(String::from("Rust"));
	 // converts &MyBox<String> into &String
	 // and then &String into &str to match function signature
	 hello(&m);
     }
   #+end_src

* threads
** =spawn=
   spawn a thread, pass a closure
   #+begin_src rust
     let handle = thread::spawn(|| {
	 for i in 1..10 {
	     println!("hi number {} from the spawned thread!", i);
	     thread::sleep(Duration::from_millis(1));
	 }
     });
   #+end_src

** =join=
   join with a terminated thread (block until thread finishes)
   #+begin_src rust
     handle.join().unwrap();
   #+end_src

** move values into thread
   =move= keyword in front of closure
   #+begin_src rust
     let v = vec![1, 2, 3];

     let handle = thread::spawn(move || {
	 println!("Here's a vector: {:?}", v);
     });
   #+end_src

** channels
   send messages between threads
   #+begin_src rust
     use std::thread;
     use std::sync::mpsc;

     fn main() {
	 let (tx, rx) = mpsc::channel();

	 thread::spawn(move || {
	     let val = String::from("hi");
	     // send
	     tx.send(val).unwrap();
	 });

	 // receive
	 let received = rx.recv().unwrap();
	 println!("Got: {}", received);
     }

   #+end_src

*** =recv=
    - blocks until a value is received
    - if sending end closes, returns Err
      #+begin_src rust
	let received = rx.recv().unwrap();
      #+end_src

*** =try_recv=
    - doesn't block, returns Result<T, E>
    - =Ok= (with message) if message available, =Err= if no message

*** using =rx= like an iterator
    iteration ends when the channel closes
    #+begin_src rust
      for received in rx {
	  println!("Got: {}", received);
      }
    #+end_src

*** =clone=
    create multiple producers by cloning the sending end of the channel
    #+begin_src rust
      let (tx, rx) = mpsc::channel();
      let tx1 = mpsc::Sender::clone(&tx);
    #+end_src

** shared access
*** Mutex<T>
    - value can only be accessed by calling =lock=
    - releases lock when =MutexGuard= goes out of scope
    - =lock= fails if thread holding lock panics
      #+begin_src rust
	use std::sync::Mutex;
	fn main() {
	    let m = Mutex::new(5);
	    {
		let mut num = m.lock().unwrap();
		,*num = 6;
	    }
	    println!("m = {:?}", m);
	}
      #+end_src

*** Arc<T>
    atomic reference counting
    - like =Rc<T>=, but can be used accross threads
    - provides interior mutability like =RefCell=
      #+begin_src rust
	use std::sync::{Mutex, Arc};
	use std::thread;

	fn main() {
	    let counter = Arc::new(Mutex::new(0));
	    let mut handles = vec![];

	    for _ in 0..10 {
		let counter = Arc::clone(&counter);
		let handle = thread::spawn(move || {
		    let mut num = counter.lock().unwrap();
		    ,*num += 1;
		});
		handles.push(handle);
	    }

	    for handle in handles {
		handle.join().unwrap();
	    }
	    println!("Result: {}", *counter.lock().unwrap());
	}

      #+end_src

* misc
** iterate thorugh lines of a string
   #+begin_src rust
     fn do_something(contents: &a str) {
	 for line in contents.lines() {
	     //...
	 }
     }
   #+end_src

** file IO
   #+begin_src rust
     use std::fs;

     fn main() {
	 let contents = fs::read_to_string("poem.txt");
     }
   #+end_src

** command line arguments
   #+begin_src rust
     use std::env;

     fn main() {
	 let args: Vec<String> = env::args().collect();
     }
   #+end_src

** print to stderr
   use =eprintln!=

* cargo
** new project
   #+begin_src shell
     cargo new <projectname>
   #+end_src

** check syntax
   #+begin_src shell
     cargo check
   #+end_src

** build
   #+begin_src shell
     # debug
     cargo build
     # release
     cargo build --release
   #+end_src

** run (compile, then run)
   #+begin_src shell
     cargo run
   #+end_src

** update crates
   #+begin_src shell
     cargo update
   #+end_src

** run tests
   #+begin_src shell
     cargo test

     # set number of threads
     cargo test -- --test-threads=1

     # show all output
     cargo test -- --show-output
   #+end_src

*** filter tests
    - pass the name of a test that should run
    - or pass a substring in the name of the tests that should run
    - or pass a module name

*** run only ignored tests
    #+begin_src shell
      cargo test -- --ignored
    #+end_src

