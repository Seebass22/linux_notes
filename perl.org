* functions
** parameters
*** shift
   #+begin_src perl
     do_something("a", "b");

     sub do_something {
         my $one = shift;
         my $two = shift;

         print $one, $two, "\n";
     }
   #+end_src
*** alternative
   #+begin_src perl
     # same as
     sub do_something {
         my ($one, $two) = @_;

         print $one, $two, "\n";
     }
   #+end_src
*** use a hash
    #+begin_src perl
      sub do_something {
          my %args = @_;

          if (exists $args{val}) {
              print "val: " . $args{val} . "\n";
          }
          if (exists $args{name}) {
              print "name: " . $args{val} . "\n";
          }
      }

      do_something(val => 1, name => "Fred");
    #+end_src

* strings
** concatenate
   #+begin_src perl
     my $str = "hello";
     $str .= " ";
     $str .= "world";
   #+end_src
** interpolate
   #+begin_src perl
     my $val = 5;
     my $str = "I have $val apples";

     # use single quotes to avoid interpolation
     my $str2 = '$val does not interpolate here'
   #+end_src
** join
   join a list into a string, separated by a separator
   #+begin_src perl
     my @list = qw( first, second, third, fourth );
     my joined = join(':', @list);
   #+end_src
** quoting
   https://perldoc.perl.org/perlop#Quote-Like-Operators
*** here document
    use single quotes to prevent interpolation
    #+begin_src perl
      my $str =<<"END";
      this is a multiline
      string. the value is $var
      END
    #+end_src
*** q
    single quoted string
    #+begin_src perl
      $foo = q!I said, "You said, 'She said it.'"!;
      $bar = q('This is it.');
    #+end_src
*** qq
    double quoted (interpolated) string
*** qw
    create a list out of words delimited by whitespace
    #+begin_src perl
      my @arr = qw(foo bar baz);
    #+end_src

* arrays
  #+begin_src perl
    my @arr = qw(one two three);
  #+end_src
** shift, unshift
   remove, add elements from start
   #+begin_src perl
     my $val = shift @arr;

     unshift @arr, $val;
   #+end_src
** pop, push
   remove, add elements from end
   #+begin_src perl
     push @arr, 5;

     my $val = pop @arr;
   #+end_src
** splice (remove elements)
  =splice ARRAY, OFFSET, LENGTH=
  remove LENGTH items at index OFFSET (can be negative)
  #+begin_src perl
    my @arr = qw( first second third );
    splice(@arr, 1, 1);
    # => [first, third]
  #+end_src

* hashes
  #+begin_src perl
    my %hash = ( key => "value",
                 key2 => "value" );

    print $hash{value};

    my $ref = \%hash;
    print $ref->{value};
  #+end_src
** delete key value pair
   #+begin_src perl
     delete $hash{value}
     delete $ref->{value}
   #+end_src

* map
  evaluate block for each element, return new list of results
  #+begin_src perl
    my @res = map { "id=$_" } @arr;
  #+end_src

* grep (filter)
  filter values (return a new list)
  #+begin_src perl
    # by regex
    my @matches = grep(/re/, @arr);

    # by any condition
    my @filtered = grep { $_->{id} > 500 } @arr;

    # longer example (read bottom to top)
    # find all items with group "finished"
    # collect just their IDs
    # sort and filter out duplicates
    my @finishedIDs =
        uniq
        sort { $a cmp $b }
        map { $_->{id} }
        grep { $_->{group} eq "finished" } @arr
  #+end_src

* List::Util
** first (find)
   like grep, but returns first element that matches predicate

* nested data structures
  use references
  #+begin_src perl
    my @arr = (1, 4, 7);
    my %hash = (first => "asdf",
                second => \@arr);

    my %nested = (first => \@arr,
                  second => \%hash);
  #+end_src

* file IO
  #+begin_src perl
    open(my $fh, "<", "input.txt");
    while (<fh>) {
      # use $_
    }

    while (my $line = <$fh>) {
    }
  #+end_src
** slurp entire file
   localize input record separator =$/=
   #+begin_src perl
     my $contents = do { local $/; <$fh> };
   #+end_src
** read file into array
   #+begin_src perl
     my @lines = <$fh>;
     # or remove newlines
     chomp(my @lines = <$fh>);
   #+end_src

* running shell programs
  #+begin_src perl
    `uname -a`
  #+end_src
** pipe to/from shell program
*** read from program
   #+begin_src perl
     $pid = open $readme, "-|", "program", "arguments" or die "Couldn't fork: $!\n";
   #+end_src
*** write to program
   #+begin_src perl
     $pid = open $readme, "|-", "program", "arguments" or die "Couldn't fork: $!\n";
   #+end_src
   
   #+begin_src perl
     $pid = open $writeme, "|-", "dot", "-Tsvg", "-o", "out.svg" or die "couldn't fork: $!\n";
     print $writeme $str;
     close $writeme;
   #+end_src

* useful CPAN modules
  list of recommended modules: https://metacpan.org/pod/Task::Kensho
** Data::Printer
   like Data::Dumper, but more human-readable
   - does not require passing references
    #+begin_src perl
      use DDP;
      p %variable;
    #+end_src
** List::Util
   useful list functions, such as =first=, =max=
** List::MoreUtils
   useful list functions missing from List::Util, such as =first_index=, =uniq=
