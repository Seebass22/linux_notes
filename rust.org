* variables
  - variables are immutable by default
    - use =mut= to make them mutable
  - you can reuse variable names to "shadow" other variables

* types
** compound types
*** tuple
    - can contain multiple types
    - fixed length
      #+begin_src rust
	fn main() {
	    // optional type annotation
	    let tup2: (i32, f64, u8) = (500, 6.4, 1);

	    let tup = (500, 6.4, 1);
	    // use pattern matching to destructure tuple
	    let (x, y, z) = tup;
	    println!("The value of y is: {}", y);

	    // access elements directly using .
	    let five_hundred = x.0;
	    let six_point_four = x.1;
	    let one = x.2;
	}
      #+end_src
*** arrays
    - elements have same type
    - fixed length
      #+begin_src rust
	let months = ["January", "February", "March", "April", "May", "June", "July",
	"August", "September", "October", "November", "December"];
	let a: [i32; 5] = [1, 2, 3, 4, 5];
	// array countaining the same element multiple times
	// [value; length]
	let a = [3; 5]; // -> [3, 3, 3, 3, 3]
      #+end_src

* structs
  - cannot be partially mutable, only completely mutable or immutable
  #+begin_src rust
    // define a struct
    struct User {
	username: String,
	email: String,
	sign_in_count: u64,
	active: bool,
    }

    // create an instance
    let mut user1 = User {
	email: String::from("someone@example.com"),
	username: String::from("someusername123"),
	active: true,
	sign_in_count: 1,
    };

    // set a field
    user1.email = String::from("anotheremail@example.com");
  #+end_src
** field init shorthand
   - possible if variable and field have the same name
     #+begin_src rust
       fn build_user(email: String, username: String) -> User {
	   User {
	       email,
	       username,
	       active: true,
	       sign_in_count: 1,
	   }
       }
     #+end_src
** struct update syntax
   create a new instance, using values from an existing instance
   #+begin_src rust
     let user2 = User {
	 email: String::from("another@example.com"),
	 username: String::from("anotherusername567"),
	 // set remaining fields (active and sign_in_count) to values from user1
	 ..user1
     };
   #+end_src
** tuple structs
   - similar to tuples, but named
   - fields are unnamed
     #+begin_src rust
       struct Color(i32, i32, i32);
       struct Point(i32, i32, i32);

       let black = Color(0, 0, 0);
       let origin = Point(0, 0, 0);
     #+end_src
** print debug info
   #+begin_src rust
     #[derive(Debug)]
     struct Rectangle {width: u32, height: u32}

     fn main() {
	 let rect1 = Rectangle { width: 30, height: 50 };

	 // compact form
	 println!("rect1 is {:?}", rect1);
	 // less compact form
	 println!("rect1 is {:#?}", rect1);
     }
   #+end_src
** methods
   - first parameter is always self
   #+begin_src rust
     struct Rectangle {
	 width: u32,
	 height: u32,
     }

     // implementation block
     impl Rectangle {
	 fn area(&self) -> u32 {
	     self.width * self.height
	 }
     }

     fn main() {
	 let rect1 = Rectangle { width: 30, height: 50 };
	 println!(
	     "The area of the rectangle is {} square pixels.",
	     // call method
	     rect1.area()
	 );
     }
   #+end_src
      
* functions
  - names in snake_case
  - can be defined anywhere (even after their use)
  - type annotations required in parameter list
  - passing a variable to a function will move or copy it
    #+begin_src rust
      fn main() {
	  function(5, 8);
      }

      fn function(x: i32, y: u32) {
	  println!("The value of x is: {}", x);
	  println!("The value of y is: {}", y);
      }
    #+end_src
** returning values
   - return value is the value of the final expresssion in the function body
   - (expressions do not use semicolons)
   #+begin_src rust
     fn five() -> i32 {
	 5
     }
     fn main() {
	 let x = five();
	 println!("The value of x is: {}", x);
     }
   #+end_src

* if
  - no parentheses required
  - is an expression
    - can be used in a let statement
      #+begin_src rust
	let condition = true;
	let number = if condition {
	    5
	} else {
	    6
	};
      #+end_src

* loops
** loop
   - infinite loop
     #+begin_src rust
       loop {
	   println!("again!");
       }
     #+end_src
   - break out with =break=
   - can return a value
     #+begin_src rust
       let mut counter = 0;

       let result = loop {
	   counter += 1;
	   if counter == 10 {
	       break counter * 2;
	   }
       };
     #+end_src
** while
   #+begin_src rust
     let mut number = 3;

     while number != 0 {
	 println!("{}!", number);
	 number = number - 1;
     }
   #+end_src
** for
   #+begin_src rust
     let a = [10, 20, 30, 40, 50];

     for element in a.iter() {
	 println!("the value is: {}", element);
     }
   #+end_src

* use
  #+begin_src rust
    std::io::Stdin
  #+end_src
  is equivalent to
  #+begin_src rust
    use std::io;

    io::Stdin
  #+end_src
  
* match
  like a switch statement
  #+begin_src rust
    match guess.cmp(&secret_number) {
	Ordering::Less => println!("Too small!"),
	Ordering::Greater => println!("Too big!"),
	Ordering::Equal => {
	    println!("You win!");
	    break;
	}
    }
  #+end_src
  
* mutability
  variables are immutable by default
  #+begin_src rust
    let x = 5;
    println!("the value of x is: {}", x);
    // compiler error
    x = 6;
    println!("the value of x is: {}", x);
  #+end_src
  use keyword =mut= for mutable variables
  #+begin_src rust
    let mut x = 5;
    println!("the value of x is: {}", x);
    x = 6;
    println!("the value of x is: {}", x);
  #+end_src
  
* shadowing
  lets you reuse names of variables
  #+begin_src rust
    let x = 5;
    let x = x + 1;
    let x = x * 2;
    println!("The value of x is: {}", x);
  #+end_src
  lets you change type
  #+begin_src rust
    let spaces = "   "
    let spaces = spaces.len();
  #+end_src
  
* constants
  - immutable
  - must be type-annotated
  - can be declared in any scope
  - must be set to a constant expression (cannot be computed at runtime)
    #+begin_src rust
      const MAX_POINTS: u32 = 100_000;
    #+end_src

* strings
** string literals
   - immutable
   - stack allocated
   - =&str= type
     #+begin_src rust
       let s = "hello";
     #+end_src
** =String= type
   - mutable
   - heap allocated
     #+begin_src rust
       let s = String::from("hello");
       // append a literal to string
       s.push_str(", world!");
       // duplicate string
       let s2 = s.clone();
     #+end_src
  - reassigning a =String= invalidates the old reference
    #+begin_src rust
      let s1 = String::from("hello");
      let s2 = s1;
      // compiler error
      println!("{}, world!", s1);
    #+end_src
*** string slices
    - reference to part of a string
    - range indices must occur at valid UTF-8 character boundaries
    - =&str= type
      #+begin_src rust
	let s = String::from("hello world");
	// [start..end]
	// does not in include "end" element
	let hello = &s[0..5];
	let world = &s[6..11];

	// you can omit the start or end if the slice includes it
	let hello = &s[..5];
	let world = &s[6..];
	// omit both values to create slice of entire string
	let slice = &s[..];
      #+end_src
    - use =&str= as function parameter instead of =&String= to make a function more general
      - allows passing both string slices (incl. string literals) and Strings
    #+begin_src rust
      fn first_word(s: &str) -> &str {
      }

      fn main() {
	  let my_string = String::from("hello world");

	  // pass slice of entire string
	  let word = first_word(&my_string[..]);

	  let my_string_literal = "hello world";
	  // pass a string literal
	  let word = first_word(&my_string_literal[..]);
	  // no need to use slice syntax since string literals are already slices
	  let word = first_word(my_string_literal);
      }
    #+end_src
    - there are array slices too, which work in the same way

* ownership
  - every value in rust has an owner
  - there can only be one owner at a time
  - when the owner goes out of scope, the value is dropped (deallocated)
  - functions take ownership of parameters
    #+begin_src rust
      {
	  let s1 = String::from("hello"); // s1 is valid
      } // s1 is no longer valid

      let s2 = String::from("hello"); // s2 comes into scope
      takes_ownership(s2); // s2's value moves into the function...
      // ... and so is no longer valid here

      let x = 5; // x comes into scope
      makes_copy(x); // x is copied (i32 is a copy type)
      // x is still valid
    #+end_src
** references
   - refer to something but do not own it
   - allow calling functions without transfering ownership
     #+begin_src rust
       fn main() {
	   let s1 = String::from("hello");
	   let len = calculate_length(&s1);
	   println!("The length of '{}' is {}.", s1, len);
       }

       fn calculate_length(s: &String) -> usize {
	   s.len()
       }
     #+end_src
   - do not allow modifying "borrowed" variable unless mutable
   - only one mutable reference to a piece of data can exist in a scope
     #+begin_src rust
       let mut s = String::from("hello");
       let r1 = &mut s;
       // compiler error
       let r2 = &mut s;
     #+end_src
   - cannot combine mutable and immutable references
     #+begin_src rust
       let mut s = String::from("hello");
       let r1 = &s; // no problem
       let r2 = &s; // no problem
       // compiler error
       let r3 = &mut s;
     #+end_src
   - cannot be dangling (must be valid)

* error handling
** expect
   print error message and quit on error
   #+begin_src rust
     let mut guess = String::new();
     io::stdin().read_line(&mut guess)
	 .expect("Failed to read line");
   #+end_src
** hand error with match
   #+begin_src rust
     let guess: u32 = match guess.trim().parse() {
	 Ok(num) => num,
	 // skip to next loop iteration on error
	 Err(_) => continue,
     };
   #+end_src

* print a variable
  #+begin_src rust
    println!("You guessed: {}", guess);
  #+end_src

* cargo
** new project
   #+begin_src shell
     cargo new <projectname>
   #+end_src
** check syntax
   #+begin_src shell
     cargo check
   #+end_src
** build
   #+begin_src shell
     # debug
     cargo build
     # release
     cargo build --release
   #+end_src
** run (compile, then run)
   #+begin_src shell
     cargo run
   #+end_src
** update crates
   #+begin_src shell
     cargo update
   #+end_src
