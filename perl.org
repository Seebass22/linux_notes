* functions
** parameters
*** shift
    #+begin_src perl
      do_something("a", "b");

      sub do_something {
          my $one = shift;
          my $two = shift;

          print $one, $two, "\n";
      }
    #+end_src
*** alternative
    #+begin_src perl
      # same as
      sub do_something {
          my ($one, $two) = @_;

          print $one, $two, "\n";
      }
    #+end_src
*** use a hash
    #+begin_src perl
      sub do_something {
          my %args = @_;

          if (exists $args{val}) {
              print "val: " . $args{val} . "\n";
          }
          if (exists $args{name}) {
              print "name: " . $args{val} . "\n";
          }
      }

      do_something(val => 1, name => "Fred");
    #+end_src

* strings
** concatenate
   #+begin_src perl
     my $str = "hello";
     $str .= " ";
     $str .= "world";
   #+end_src
** interpolate
   #+begin_src perl
     my $val = 5;
     my $str = "I have $val apples";

     # use single quotes to avoid interpolation
     my $str2 = '$val does not interpolate here'
   #+end_src
** join
   join a list into a string, separated by a separator
   #+begin_src perl
     my @list = qw( first, second, third, fourth );
     my joined = join(':', @list);
   #+end_src
** quoting
   https://perldoc.perl.org/perlop#Quote-Like-Operators
*** here document
    use single quotes to prevent interpolation
    #+begin_src perl
      my $str =<<"END";
      this is a multiline
      string. the value is $var
      END
    #+end_src
*** q
    single quoted string
    #+begin_src perl
      $foo = q!I said, "You said, 'She said it.'"!;
      $bar = q('This is it.');
    #+end_src
*** qq
    double quoted (interpolated) string
*** qw
    create a list out of words delimited by whitespace
    #+begin_src perl
      my @arr = qw(foo bar baz);
    #+end_src

* arrays
  #+begin_src perl
    my @arr = qw(one two three);
  #+end_src
** shift, unshift
   remove, add elements from start
   #+begin_src perl
     my $val = shift @arr;

     unshift @arr, $val;
   #+end_src
** pop, push
   remove, add elements from end
   #+begin_src perl
     push @arr, 5;

     my $val = pop @arr;
   #+end_src
** splice (remove elements)
   =splice ARRAY, OFFSET, LENGTH=
   remove LENGTH items at index OFFSET (can be negative)
   #+begin_src perl
     my @arr = qw( first second third );
     splice(@arr, 1, 1);
     # => [first, third]
   #+end_src

* hashes
  #+begin_src perl
    my %hash = ( key => "value",
                 key2 => "value" );

    print $hash{value};

    my $ref = \%hash;
    print $ref->{value};
  #+end_src
** delete key value pair
   #+begin_src perl
     delete $hash{value}
       delete $ref->{value}
   #+end_src
** hash slices
   #+begin_src perl
     my %capital_of = (
         Germany => 'Berlin',
         France => 'Paris',
         China => 'Beijing',
     );

     # extract list from hash
     my @capitals = @capital_of{'Germany', 'China'};
     # => ('Berlin', 'Beijing')

     # assign to hash using slice
     @capital_of{'Japan', 'Norway'} = ('Tokyo', 'Oslo');
     # => {
     #     Germany => 'Berlin',
     #     France => 'Paris',
     #     China => 'Beijing',
     #     Japan => 'Tokyo',
     #     Norway => 'Oslo',
     # };
   #+end_src

* map
  evaluate block for each element, return new list of results
  #+begin_src perl
    my @res = map { "id=$_" } @arr;
  #+end_src

* grep (filter)
  filter values (return a new list)
  #+begin_src perl
    # by regex
    my @matches = grep(/re/, @arr);

    # by any condition
    my @filtered = grep { $_->{id} > 500 } @arr;

    # longer example (read bottom to top)
    # find all items with group "finished"
    # collect just their IDs
    # sort and filter out duplicates (uniq does not require list to be sorted first)
    my @finishedIDs =
      uniq
      sort { $a cmp $b }
      map { $_->{id} }
      grep { $_->{group} eq "finished" } @arr
  #+end_src

* List::Util
** first (find)
   like grep, but returns first element that matches predicate

* nested data structures
  use references
  #+begin_src perl
    my @arr = (1, 4, 7);
    my %hash = (first => "asdf",
                second => \@arr);

    my %nested = (first => \@arr,
                  second => \%hash);
  #+end_src

* file IO
** read linewise
   #+begin_src perl
     open(my $fh, "<", "input.txt");

     while (my $line = <$fh>) {
     }
   #+end_src
** slurp entire file
   localize input record separator =$/=
   #+begin_src perl
     my $contents = do { local $/; <$fh> };
   #+end_src
** read file into array
   #+begin_src perl
     my @lines = <$fh>;
     # or remove newlines
     chomp(my @lines = <$fh>);
   #+end_src

* running shell programs
  #+begin_src perl
    `uname -a`
  #+end_src
** pipe to/from shell program
*** read from program
    #+begin_src perl
      $pid = open $readme, "-|", "program", "arguments" or die "Couldn't fork: $!\n";
    #+end_src
*** write to program
    #+begin_src perl
      $pid = open $readme, "|-", "program", "arguments" or die "Couldn't fork: $!\n";
    #+end_src
   
    #+begin_src perl
      $pid = open $writeme, "|-", "dot", "-Tsvg", "-o", "out.svg" or die "couldn't fork: $!\n";
      print $writeme $str;
      close $writeme;
    #+end_src

* profiling code
** Devel::NYTProf
   - installable from CPAN
     #+begin_src shell
       # profile code and write database to ./nytprof.out
       perl -d:NYTProf some_perl.pl

       # convert database to HTML and open in browser
       nytprofhtml --open
     #+end_src

* regex 
** check if match
   #+begin_src perl
     if ($string =~ m/PATTERN/) {
     }
     # m operator is implied if slashes are used as delimiters
     if ($string =~ /PATTERN/) {
     }
   #+end_src
** modifiers
   #+begin_src perl
     if ($string =~ m/PATTERN/msix) {
     }
   #+end_src
*** m
    treat string as multiple lines,
    change =^= and =$= to mean start and end of string
    (rather than of the string's lines)
*** s
    treat string as a single line, allowing =.= to match newlines
*** i
    case insensitive match
*** x
    permit whitespace in patters to allow comments

* useful CPAN modules
  list of recommended modules: https://metacpan.org/pod/Task::Kensho
** Data::Printer
   like Data::Dumper, but more human-readable
   - does not require passing references
     #+begin_src perl
       use DDP;
       p %variable;
     #+end_src
** List::Util
   useful list functions, such as =first=, =max=
** List::MoreUtils
   useful list functions missing from List::Util, such as =first_index=, =uniq=
