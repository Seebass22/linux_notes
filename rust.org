* variables
  - variables are immutable by default
    - use =mut= to make them mutable
  - you can reuse variable names to "shadow" other variables

* types
** compound types
*** tuple
    - can contain multiple types
    - fixed length
      #+begin_src rust
	fn main() {
	    // optional type annotation
	    let tup2: (i32, f64, u8) = (500, 6.4, 1);

	    let tup = (500, 6.4, 1);
	    // use pattern matching to destructure tuple
	    let (x, y, z) = tup;
	    println!("The value of y is: {}", y);

	    // access elements directly using .
	    let five_hundred = x.0;
	    let six_point_four = x.1;
	    let one = x.2;
	}
      #+end_src
*** arrays
    - elements have same type
    - fixed length
    - can be sliced just like strings
      #+begin_src rust
	let months = ["January", "February", "March", "April", "May", "June", "July",
	"August", "September", "October", "November", "December"];
	let a: [i32; 5] = [1, 2, 3, 4, 5];
	// array countaining the same element multiple times
	// [value; length]
	let a = [3; 5]; // -> [3, 3, 3, 3, 3]
      #+end_src

* collections
  data structures in the standard library
  - stored on heap
** vectors
   #+begin_src rust
     let v: Vec<i32> = Vec::new();

     v.push(5);
     v.push(6);
     v.push(7);
     v.push(8);
   #+end_src
*** vec! macro
    create a vector with initial values
    #+begin_src rust
      let v = vec![1, 2, 3];
    #+end_src
*** reading elements
    #+begin_src rust
      let v = vec![1, 2, 3, 4, 5];
      let third: &i32 = &v[2];

      println!("The third element is {}", third);

      match v.get(2) {
	  Some(third) => println!("The third element is {}", third),
	  None => println!("There is no third element."),
      }
    #+end_src
*** iterating over vector
    #+begin_src rust
      // iterate over vector
      let v = vec![100, 32, 57];
      for i in &v {
	  println!("{}", i);
      }

      // iterate over mutable reference to vector
      let mut v = vec![100, 32, 57];
      for i in &mut v {
	  *i += 50;
      }
    #+end_src
** hash maps
   - key/value pairs
   #+begin_src rust
     use std::collections::HashMap;

     let mut scores = HashMap::new();
     scores.insert(String::from("Blue"), 10);
     scores.insert(String::from("Yellow"), 50);

     // access values
     let team_name = String::from("Blue");
     let score = scores.get(&team_name);
     // returns Some(&10)
     // would return None if no value for the key exists
   #+end_src
*** create hash map from vectors
    #+begin_src rust
      use std::collections::HashMap;

      let teams = vec![String::from("Blue"), String::from("Yellow")];
      let initial_scores = vec![10, 50];

      let scores: HashMap<_, _> = teams.iter()
	  // create vector of tuples (Blue, 10), (Yellow, 50)
	  .zip(initial_scores.iter())
	  // turn into hash map
	  .collect();
    #+end_src
*** iterate over key/value pairs
    #+begin_src rust
      for (key, value) in &scores {
	  println!("{}: {}", key, value);
      }
    #+end_src
*** iterate over keys
    =.keys()=
*** iterate over values
    =.values()=
*** overwrite value
    #+begin_src rust
      scores.insert(String::from("Blue"), 10);
      scores.insert(String::from("Blue"), 25);
    #+end_src
*** only insert if key has no value
    #+begin_src rust
      scores.entry(String::from("Yellow")).or_insert(50);
      scores.entry(String::from("Blue")).or_insert(50);
    #+end_src
*** update value based on its old value
    - =or_insert= returns a mutable reference to the value
    #+begin_src rust
      use std::collections::HashMap;

      let text = "hello world wonderful world";
      let mut map = HashMap::new();

      for word in text.split_whitespace() {
	  let count = map.entry(word).or_insert(0);
	  *count += 1;
      }
      println!("{:?}", map);
      // {"world": 2, "hello": 1, "wonderful": 1}
    #+end_src

* structs
  - cannot be partially mutable, only completely mutable or immutable
  #+begin_src rust
    // define a struct
    struct User {
	username: String,
	email: String,
	sign_in_count: u64,
	active: bool,
    }

    // create an instance
    let mut user1 = User {
	email: String::from("someone@example.com"),
	username: String::from("someusername123"),
	active: true,
	sign_in_count: 1,
    };

    // set a field
    user1.email = String::from("anotheremail@example.com");
  #+end_src
** field init shorthand
   - possible if variable and field have the same name
     #+begin_src rust
       fn build_user(email: String, username: String) -> User {
	   User {
	       email,
	       username,
	       active: true,
	       sign_in_count: 1,
	   }
       }
     #+end_src
** struct update syntax
   create a new instance, using values from an existing instance
   #+begin_src rust
     let user2 = User {
	 email: String::from("another@example.com"),
	 username: String::from("anotherusername567"),
	 // set remaining fields (active and sign_in_count) to values from user1
	 ..user1
     };
   #+end_src
** tuple structs
   - similar to tuples, but named
   - fields are unnamed
     #+begin_src rust
       struct Color(i32, i32, i32);
       struct Point(i32, i32, i32);

       let black = Color(0, 0, 0);
       let origin = Point(0, 0, 0);
     #+end_src
** print debug info
   #+begin_src rust
     #[derive(Debug)]
     struct Rectangle {width: u32, height: u32}

     fn main() {
	 let rect1 = Rectangle { width: 30, height: 50 };

	 // compact form
	 println!("rect1 is {:?}", rect1);
	 // less compact form
	 println!("rect1 is {:#?}", rect1);
     }
   #+end_src
** methods
   - first parameter is always self
   #+begin_src rust
     struct Rectangle {
	 width: u32,
	 height: u32,
     }

     // implementation block
     impl Rectangle {
	 fn area(&self) -> u32 {
	     self.width * self.height
	 }
     }

     fn main() {
	 let rect1 = Rectangle { width: 30, height: 50 };
	 println!(
	     "The area of the rectangle is {} square pixels.",
	     // call method
	     rect1.area()
	 );
     }
   #+end_src
** associated functions
   - like static methods in other languages
   - not associated with an instance
   - often used as constructors
   - use =::= to call
     #+begin_src rust
       impl Rectangle {
	   fn square(size: u32) -> Rectangle {
	       Rectangle { width: size, height: size }
	   }
       }

       fn main(){
	   let sq = Rectangle::square(3)
       }
     #+end_src

* enums
  - can have methods
  - can contain data (of different types)
    #+begin_src rust
      enum IpAddr {
	  V4(u8, u8, u8, u8),
	  V6(String),
      }
      let home = IpAddr::V4(127, 0, 0, 1);
      let loopback = IpAddr::V6(String::from("::1"));
    #+end_src
** option enum
   #+begin_src rust
     enum Option<T> {
	 Some(T),
	 None,
     }
   #+end_src
   - automatically included in prelude
   - can use =Some= and =None= without =Option::= prefix
   #+begin_src rust
     let some_number = Some(5);
     let some_string = Some("a string");
     let absent_number: Option<i32> = None;
   #+end_src
   - use =match= to get value
   #+begin_src rust
     fn plus_one(x: Option<i32>) -> Option<i32> {
	 // return None if None
	 // else add 1 to value
	 match x {
	     None => None,
	     Some(i) => Some(i + 1),
	 }
     }
     let five = Some(5);
     let six = plus_one(five);
     let none = plus_one(None);
   #+end_src
   - use =unwrap= to return value (only if you're sure a value is present)
     - will panic if None
  
* functions
  - names in =snake_case=
  - can be defined anywhere (even after their use)
  - type annotations required in parameter list
  - passing a variable to a function will move or copy it
    #+begin_src rust
      fn main() {
	  function(5, 8);
      }

      fn function(x: i32, y: u32) {
	  println!("The value of x is: {}", x);
	  println!("The value of y is: {}", y);
      }
    #+end_src
** returning values
   - return value is the value of the final expresssion in the function body
   - (expressions do not use semicolons)
   #+begin_src rust
     fn five() -> i32 {
	 5
     }
     fn main() {
	 let x = five();
	 println!("The value of x is: {}", x);
     }
   #+end_src

* if
  - no parentheses required
  - is an expression
    - can be used in a let statement
      #+begin_src rust
	let condition = true;
	let number = if condition {
	    5
	} else {
	    6
	};
      #+end_src

* loops
** loop
   - infinite loop
     #+begin_src rust
       loop {
	   println!("again!");
       }
     #+end_src
   - break out with =break=
   - can return a value
     #+begin_src rust
       let mut counter = 0;

       let result = loop {
	   counter += 1;
	   if counter == 10 {
	       break counter * 2;
	   }
       };
     #+end_src
** while
   #+begin_src rust
     let mut number = 3;

     while number != 0 {
	 println!("{}!", number);
	 number = number - 1;
     }
   #+end_src
** for
   #+begin_src rust
     let a = [10, 20, 30, 40, 50];

     for element in a.iter() {
	 println!("the value is: {}", element);
     }
   #+end_src

* use
  #+begin_src rust
    std::io::Stdin
  #+end_src
  is equivalent to
  #+begin_src rust
    use std::io;

    io::Stdin
  #+end_src
  - works with user defined modules too
    #+begin_src rust
      mod front_of_house {
	  pub mod hosting {
	      pub fn add_to_waitlist() {}
	  }
      }

      use crate::front_of_house::hosting;
      // or use relative path
      // use front_of_house::hosting;

      pub fn eat_at_restaurant() {
	  hosting::add_to_waitlist();
	  hosting::add_to_waitlist();
      }
    #+end_src
** nested paths
   #+begin_src rust
     use std::{io, cmp::Ordering};
   #+end_src
** glob operator
   - brings all public items into scope
     #+begin_src rust
       use std::collections::*;
     #+end_src
** =as= keyword
   - allows you to use a different name
     #+begin_src rust
       use std::fmt::Result;
       use std::io::Result as IoResult;

       fn function1() -> Result {
	   // --snip--
       }
       fn function2() -> IoResult<()> {
	   // --snip--
       }
     #+end_src
** re-exporting with =pub use=
   - bring an item into scope and make it avaiable for others
   #+begin_src rust
     // allow external code to call hosting::add_to_waitlist without full path
     pub use crate::front_of_house::hosting;
   #+end_src
  
* match
  - like a switch statement
  - can extract values from enums 
  - must cover every possible case
  - =_= matches any value
  #+begin_src rust
    match guess.cmp(&secret_number) {
	Ordering::Less => println!("Too small!"),
	Ordering::Greater => println!("Too big!"),
	Ordering::Equal => {
	    println!("You win!");
	    break;
	}
    }

    let some_u8_value = 0u8;
    match some_u8_value {
	1 => println!("one"),
	3 => println!("three"),
	5 => println!("five"),
	7 => println!("seven"),
	_ => (),
    }
  #+end_src
** if let
   - takes a pattern and expression separated by equals
     #+begin_src rust
       let some_u8_value = Some(0u8);

       if let Some(3) = some_u8_value {
	   println!("three");
       }

       // same as
       match some_u8_value {
	   Some(3) => println!("three"),
	   _ => (),
       }
     #+end_src
  
* mutability
  variables are immutable by default
  #+begin_src rust
    let x = 5;
    println!("the value of x is: {}", x);
    // compiler error
    x = 6;
    println!("the value of x is: {}", x);
  #+end_src
  use keyword =mut= for mutable variables
  #+begin_src rust
    let mut x = 5;
    println!("the value of x is: {}", x);
    x = 6;
    println!("the value of x is: {}", x);
  #+end_src
  
* shadowing
  lets you reuse names of variables
  #+begin_src rust
    let x = 5;
    let x = x + 1;
    let x = x * 2;
    println!("The value of x is: {}", x);
  #+end_src
  lets you change type
  #+begin_src rust
    let spaces = "   "
    let spaces = spaces.len();
  #+end_src
  
* constants
  - immutable
  - must be type-annotated
  - can be declared in any scope
  - must be set to a constant expression (cannot be computed at runtime)
    #+begin_src rust
      const MAX_POINTS: u32 = 100_000;
    #+end_src

* strings
** string literals
   - immutable
   - stack allocated
   - =&str= type
     #+begin_src rust
       let s = "hello";
     #+end_src
** =String= type
   - mutable
   - heap allocated
     #+begin_src rust
       let s = String::from("hello");
       // append a literal to string
       s.push_str(", world!");
       // duplicate string
       let s2 = s.clone();
       // append single character
       let mut s3 = String::from("lo");
       s3.push('l');
       // concatenate 2 strings
       let s1 = String::from("Hello, ");
       let s2 = String::from("world!");
       let s3 = s1 + &s2; // s1 has been moved here and can no longer be used
       // alternatively use format! macro
     #+end_src
  - reassigning a =String= invalidates the old reference
    #+begin_src rust
      let s1 = String::from("hello");
      let s2 = s1;
      // compiler error
      println!("{}, world!", s1);
    #+end_src
*** to_string
    - works on any type that implements the =Display= trait
    #+begin_src rust
      let data = "initial contents";
      let s = data.to_string();
      // also works on a literal directly
      let s = "initial contents".to_string();
    #+end_src
*** format! macro
    - works like println! but returns a string instead of printing it
    #+begin_src rust
      let s1 = String::from("tic");
      let s2 = String::from("tac");
      let s3 = String::from("toe");

      let s = format!("{}-{}-{}", s1, s2, s3);
    #+end_src
*** iterating over strings
**** over unicode scalar values
     #+begin_src rust
       // return chars
       for c in "नमस्त".chars() {
	   println!("{}", c);
       }

       // return raw bytes
       for b in "नमस्त".bytes() {
	   println!("{}", b);
       }
     #+end_src
*** check if string contains substring
    #+begin_src rust
      if s.contains("ab") {
	  //..
      }
    #+end_src
** string slices
   - reference to part of a string
   - range indices must occur at valid UTF-8 character boundaries
   - are of type =&str=
     #+begin_src rust
       let s = String::from("hello world");
       // [start..end]
       // does not in include "end" element
       let hello = &s[0..5];
       let world = &s[6..11];

       // you can omit the start or end if the slice includes it
       let hello = &s[..5];
       let world = &s[6..];
       // omit both values to create slice of entire string
       let slice = &s[..];
     #+end_src
   - use =&str= as function parameter instead of =&String= to make a function more general
     - allows passing both string slices (incl. string literals) and Strings
   #+begin_src rust
     fn first_word(s: &str) -> &str {
     }

     fn main() {
	 let my_string = String::from("hello world");

	 // pass slice of entire string
	 let word = first_word(&my_string[..]);

	 let my_string_literal = "hello world";
	 // pass a string literal
	 let word = first_word(&my_string_literal[..]);
	 // no need to use slice syntax since string literals are already slices
	 let word = first_word(my_string_literal);
     }
   #+end_src
   - there are array slices too, which work in the same way

* ownership
  - every value in rust has an owner
  - there can only be one owner at a time
  - when the owner goes out of scope, the value is dropped (deallocated)
  - functions take ownership of parameters
    #+begin_src rust
      {
	  let s1 = String::from("hello"); // s1 is valid
      } // s1 is no longer valid

      let s2 = String::from("hello"); // s2 comes into scope
      takes_ownership(s2); // s2's value moves into the function...
      // ... and so is no longer valid here

      let x = 5; // x comes into scope
      makes_copy(x); // x is copied (i32 is a copy type)
      // x is still valid
    #+end_src
** references
   - refer to something but do not own it
   - allow calling functions without transfering ownership
     #+begin_src rust
       fn main() {
	   let s1 = String::from("hello");
	   let len = calculate_length(&s1);
	   println!("The length of '{}' is {}.", s1, len);
       }

       fn calculate_length(s: &String) -> usize {
	   s.len()
       }
     #+end_src
   - do not allow modifying "borrowed" variable unless mutable
   - only one mutable reference to a piece of data can exist in a scope
     #+begin_src rust
       let mut s = String::from("hello");
       let r1 = &mut s;
       // compiler error
       let r2 = &mut s;
     #+end_src
   - cannot combine mutable and immutable references
     #+begin_src rust
       let mut s = String::from("hello");
       let r1 = &s; // no problem
       let r2 = &s; // no problem
       // compiler error
       let r3 = &mut s;
     #+end_src
   - cannot be dangling (must be valid)

* error handling
** =Result= enum
   #+begin_src rust
     enum Result<T, E> {
	 Ok(T),
	 Err(E),
     }
   #+end_src
   - automatically included in prelude, like =Option=
** expect
   print error message and quit on error
   - works like =unwrap=
   #+begin_src rust
     let mut guess = String::new();
     io::stdin().read_line(&mut guess)
	 .expect("Failed to read line");
   #+end_src
** handle error with match
   #+begin_src rust
     let guess: u32 = match guess.trim().parse() {
	 Ok(num) => num,
	 // skip to next loop iteration on error
	 Err(_) => continue,
     };
   #+end_src
*** match multiple error types
    #+begin_src rust
      use std::fs::File;
      use std::io::ErrorKind;

      fn main() {
	  let f = File::open("hello.txt");

	  let f = match f {
	      Ok(file) => file,
	      Err(error) => match error.kind() {
		  ErrorKind::NotFound => match File::create("hello.txt") {
		      Ok(fc) => fc,
		      Err(e) => panic!("Problem creating the file: {:?}", e),
		  },
		  other_error => panic!("Problem opening the file: {:?}", other_error),
	      },
	  };
      }
    #+end_src
** propogating errors
   - return a =Result=
   #+begin_src rust
     use std::io;
     use std::io::Read;
     use std::fs::File;

     fn read_username_from_file() -> Result<String, io::Error> {
	 let f = File::open("hello.txt");
	 let mut f = match f {
	     Ok(file) => file,
	     Err(e) => return Err(e),
	 };

	 let mut s = String::new();
	 match f.read_to_string(&mut s) {
	     Ok(_) => Ok(s),
	     Err(e) => Err(e),
	 }
     }
   #+end_src
*** shorthand: =?= operator
    - returns value inside Ok to expression if Ok
    - returns Err from the whole function if Err
      - uses =From= trait to convert between error types
      - can only be used in functions that return =Result= enum
    #+begin_src rust
      use std::io;
      use std::io::Read;
      use std::fs::File;

      fn read_username_from_file() -> Result<String, io::Error> {
	  let mut f = File::open("hello.txt")?;
	  let mut s = String::new();
	  f.read_to_string(&mut s)?;
	  Ok(s)
      }
    #+end_src
    or chain calls
    #+begin_src rust
      use std::io;
      use std::io::Read;
      use std::fs::File;

      fn read_username_from_file() -> Result<String, io::Error> {
	  let mut s = String::new();
	  File::open("hello.txt")?.read_to_string(&mut s)?;
	  Ok(s)
      }
    #+end_src
** any kind of error
   =Box<dyn Error>>=

* generics
** functions
   #+begin_src rust
     fn do_something<T>(list: &[T]) -> T {
     }
   #+end_src
** structs and methods
   #+begin_src rust
     struct Point<T> {
	 x: T,
	 y: T,
     }

     // method for all types
     impl<T> Point<T> {
	 fn x(&self) -> &T {
	     &self.x
	 }
     }

     // method just for f32
     impl Point<f32> {
	 fn distance_from_origin(&self) -> f32 {
	     (self.x.powi(2) + self.y.powi(2)).sqrt()
	 }
     }
   #+end_src

* traits
  - similar to interfaces in other languages
  - can only be implemented if the trait or type is local to the crate
    (can't implement external traits on external types)
    #+begin_src rust
      // trait definition
      pub trait Summary {
	  fn summarize(&self) -> String;
      }

      pub struct NewsArticle {
	  pub headline: String,
	  pub location: String,
	  pub author: String,
	  pub content: String,
      }

      // implement Summary trait for NewsArticle
      impl Summary for NewsArticle {
	  fn summarize(&self) -> String {
	      format!("{}, by {} ({})", self.headline, self.author, self.location)
	  }
      }

      pub struct Tweet {
	  pub username: String,
	  pub content: String,
	  pub reply: bool,
	  pub retweet: bool,
      }

      // implement Summary trait for Tweet
      impl Summary for Tweet {
	  fn summarize(&self) -> String {
	      format!("{}: {}", self.username, self.content)
	  }
      }
    #+end_src
** default implementations
   - can mix default and required implementations in one trait
   - cannot call default implementation from overriding one
   #+begin_src rust
     // definition
     pub trait Summary {
	 fn summarize(&self) -> String {
	     String::from("(Read more...)")
	 }
     }

     // use default implementation of Summary for NewsArticle
     impl Summary for NewsArticle {}
   #+end_src
** traits as parameters
   #+begin_src rust
     // takes any type that implements Summary trait as parameter
     pub fn notify(item: impl Summary) {
	 println!("Breaking news! {}", item.summarize());
     }
   #+end_src
*** trait bound syntax
    #+begin_src rust
      pub fn notify<T: Summary>(item: T) {
	  println!("Breaking news! {}", item.summarize());
      }
    #+end_src
*** multiple trait bounds
    #+begin_src rust
      pub fn notify(item: impl Summary + Display) {}
	  // or
      pub fn notify<T: Summary + Display>(item: T) {}
    #+end_src
*** =where= clauses
    #+begin_src rust
      fn some_function<T, U>(t: T, u: U) -> i32
	  where T: Display + Clone,
	      U: Clone + Debug
      {}
      // same as
      fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {}
    #+end_src
*** conditionally implement method if traits are implemented
    #+begin_src rust
      impl<T: Display + PartialOrd> Pair<T> {
    #+end_src
*** implement trait if other traits are implemented
    #+begin_src rust
      impl<T: Display> ToString for T {
    #+end_src
** traits as return types
   - only works if function/method returns only one type
   #+begin_src rust
     fn returns_summarizable() -> impl Summary {
   #+end_src

* print a variable
  #+begin_src rust
    println!("You guessed: {}", guess);
  #+end_src

* modules
  - put something in a module if you want it to be private
  #+begin_src rust
    mod front_of_house {
	pub mod hosting {
	    pub fn add_to_waitlist() {}
	}
    }
  #+end_src
  - can be called with absolute (with =crate::=) or relative path
    #+begin_src rust
      pub fn eat_at_restaurant() {
	  // Absolute path
	  crate::front_of_house::hosting::add_to_waitlist();
	  // Relative path
	  front_of_house::hosting::add_to_waitlist();
      }
    #+end_src
  - reference parent module with =super::=
    #+begin_src rust
      fn serve_order() {}

      mod back_of_house {
	  fn fix_incorrect_order() {
	      cook_order();
	      super::serve_order();
	  }

	  fn cook_order() {}
      }
    #+end_src
** public structs
   - use keyword =pub= to designate structs and enums as public
   - the fields will remain private, can be made public on case-by-case basis
     #+begin_src rust
       mod back_of_house {
	   pub struct Breakfast {
	       pub toast: String,
	       seasonal_fruit: String,
	   }

	   impl Breakfast {
	       pub fn summer(toast: &str) -> Breakfast {
		   Breakfast {
		       toast: String::from(toast),
		       seasonal_fruit: String::from("peaches"),
		   }
	       }
	   }
       }
       pub fn eat_at_restaurant() {
	   // Order a breakfast in the summer with Rye toast
	   let mut meal = back_of_house::Breakfast::summer("Rye");
	   // Change our mind about what bread we'd like
	   meal.toast = String::from("Wheat");
	   println!("I'd like {} toast please", meal.toast);

	   // compiler error - cannot modify private field seasonal_fruit
	   meal.seasonal_fruit = String::from("blueberries");
       }
     #+end_src
** public enums
   - enums are public by default

* cargo
** new project
   #+begin_src shell
     cargo new <projectname>
   #+end_src
** check syntax
   #+begin_src shell
     cargo check
   #+end_src
** build
   #+begin_src shell
     # debug
     cargo build
     # release
     cargo build --release
   #+end_src
** run (compile, then run)
   #+begin_src shell
     cargo run
   #+end_src
** update crates
   #+begin_src shell
     cargo update
   #+end_src
